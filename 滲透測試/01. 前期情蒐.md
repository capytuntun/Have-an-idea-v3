>[!NOTE]
> - 先發現服務名稱
> - 依照服務去做發想，並針對服務利用特定工具做列舉。
# DNS 偵蒐
>[!WARNING]
> - DNS爆破
> - DNS Zone Transfer
### DNS介紹
DNS是由多種不同身分的腳色所組成的，他主要有以下幾種身分
- DNS root server : 屬於 top-level domains (`TLD`)，也就是整個網際網路中 **域名系統（DNS）** 的最高層級伺服器，用來協助解析網址到實際的 IP 位址。簡單來說，它是 DNS 查詢過程的「起點」，目前 DNS root server由(`ICANN`)管理，並且全球共有13個。
- Authoritative name server : （授權名稱伺服器）是 DNS 系統中的一個關鍵角色，它**擁有並提供某個網域名稱的最終、正確答案**。當 DNS 查詢最終抵達該伺服器時，它會回應該網域的實際記錄（例如 A、MX、TXT 等），可以把它當成網址與ip位置儲存的真正的伺服器。
- Non-authoritative name server : （**非授權名稱伺服器**）是 DNS 系統中能夠提供某個網域查詢結果的伺服器，但**它不是該網域的原始來源**，而是從其他伺服器取得資料後，**暫時快取（cache）這些結果**來回應查詢。
- Caching server : （快取 DNS 伺服器）是一種 **儲存其他伺服器查詢結果** 的 DNS 伺服器，用來加速 DNS 查詢、減少頻繁的查詢量，並提高整體解析效率。
- Forwarding server : **Forwarding DNS Server** 是一種設定為**把所有 DNS 查詢轉送給另一台指定 DNS 伺服器**的 DNS server，它**不會自己遞迴查詢 root、TLD、authoritative server**，而是把查詢交給上游 DNS resolver 處理，主要用於公司內部的DNS Server
- Resolver :  是負責**遞迴查詢 DNS 記錄**的伺服器，最終找到正確答案（可能來自快取或詢問授權伺服器），嚴格來說並不是DNS 伺服器。
DNS 查詢的流程圖
```
Client → Forwarding DNS Server → Upstream Resolver（如 8.8.8.8）→ 正規 DNS 查詢鏈
```
## DNS 偵蒐
- **A 紀錄（Address Record）**：  
    包含該網域的 **IPv4 位址**，讓瀏覽器知道要連到哪一台主機。
- **MX 紀錄（Mail Exchange）**：  
    指定用來 **處理該網域電子郵件的郵件伺服器**，常見於設定企業信箱。
- **CNAME 紀錄（Canonical Name）**：  
    用來設定 **子網域的別名指向另一個網域名稱**，例如讓 `blog.example.com` 指向 `example.com`。
- **NS 紀錄（Name Server）**：  
    指出 **負責該網域的授權名稱伺服器**，是 DNS 系統中重要的控制點之一。
- **SOA 紀錄（Start of Authority）**：  
    包含關於網域的重要資訊，例如 **主要名稱伺服器、最後更新時間、負責人資訊等**，是每個 DNS 區域檔的起點。
- **PTR 紀錄（Pointer Record）**：  
    將 **IPv4 位址對應回主機名稱**，稱為「反向 DNS 紀錄」，常見於電子郵件伺服器驗證。
- **TXT 紀錄（Text Record）**：  
    可由管理員加入 **任意文字資訊**，常用於 **SPF、DKIM、DMARC** 等郵件驗證設定，或是提供其他說明資訊。

```
nslookup google.com
```
```
nslookup -type=txt google.com
nslookup -type=mx google.com
nslookup -type=any google.com
```
```
nslookup -type=any google.com 8.8.8.8
```
```
host 8.8.8.8
```
```
dig -t mx google.co
dig -t any google.com @8.8.8.8
```
```
fierce --domain google.com
fierce --domain google.com --subdomain-file [path to wordlist]
```
##  DNS 爆破
>[!NOTE]
> OSCP應該不會考

-  Wordlist爆破法 
```
for ip in $(cat list.txt); do host $ip.megacorpone.com; done
```
- dnsrecon
```
dnsrecon -d megacorpone.com -t std
```
- dnsrecon
```
dnsrecon -d megacorpone.com -D ~/list.txt -t brt
```
- DNSEnum
```
dnsenum megacorpone.com
```

指令裡面提到的list.txt代表需要自行準備字典檔

``` 
www
ftp
mail
owa
proxy
router
```
## DNS Zone Transfer
``` shell
dig AXFR @ns1.inlanefreight.htb inlanefreight.htb
```
```shell
dig axfr inlanefreight.local @10.129.203.101
```
``` shell 
fierce --domain zonetransfer.me
```
## Security Headers and SSL/Tools 
>[!WARNING]
>表頭為網頁進入點其中一個方向
### HTTP
``` 
nc www.google.com 80
HEAD / HTTP/1.1

HOST: www.google.com
```
### HTTPS
``` 
openssl s_client -connect www.google.com:443
```
# Open-Source Code

>利用github尋找密碼的小工具
## Gitleaks
``` 
gitleak -v -r=http://github.com/XXXX
```
# 埠位掃描
>[!NOTE]
>列舉出host裡面有跑哪些服務

>[!NOTE]
>一般用nmap，rustscan可以跑更快，是個OSCP friendly的工具。
## 利用netcat

>OSCP 2023教材
### nc做tcp掃描
```
nc -nvv -w 1 -z 192.168.50.152 3388-3390
```
### nc做udp掃描 
```
nc -nv -u -z -w 1 192.168.50.149 120-123
```

## Test-NetConnection
>[!NOTE]
>powershell內建的連線測試工具
```
Test-NetConnection -Port 445 192.168.50.151
```
## Living Off-the-Land（LoL）
>[!NOTE]
>利用原生工具做掃描，於取得初始感染點後可以用這種方式，就不用另外打tunnel或是上傳工具。
### Host Discovery
- Bash Ping Sweep
```
for ip in {1..254}; do (ping -c 1 192.168.0.$ip | grep "bytes from" &); done
```
- Cmd Ping Sweep
```cmd-session
for /L %i in (1 1 254) do ping 172.16.5.%i -n 1 -w 100 | find "Reply"
```
```
for /L %i in (1,1,255) do @ping -n 1 -w 200 172.16.6.%i > nul && echo 172.16.6.%i is up.
```
### TCP Port 掃描
- Bash Port Scan
```
for port in {1..1024}; do (echo > /dev/tcp/192.168.0.7/$port && echo $port open) 2> /dev/null; done
```
- Powershell Port Scan
```
1..1024 | % {echo ((New-Object Net.Sockets.TcpClient).Connect("192.168.50.151", $_)) "TCP port $_ is open"} 2>$null
```

# Nmap
>[!NOTE]
>- Nmap 使用範圍
>	- Host discovery
>	- Port scanning
>	- Service enumeration and detection
>	- OS detection
>	- Scriptable interaction with the target service (Nmap Scripting Engine)
## 存活主機探索(Host Discovery)
>[!NOTE]
>當需要在某個子網的範圍內，搜索有開機的主機的時候，或是說探索這個子網內部有哪些主機時，可以用nmap的host discovery來做探索。

### 掃描整個子網
假設子網的ip是`192.168.1.0/24`，可以這樣執行。
```
nmap 192.168.1.0 -sn
```
- -sn : 關閉port scanning

如果需要彙整成清單的話，可以利用這個功能
```
nmap 192.168.1.0 -sn -oA tnet | grep for | cut -d" " -f5
```
- oA : 輸出成tnet格式
### 使用ip清單
>[!NOTE]
>假設手上有一個ip的清單，想要快速掌握那些ip位置有存活

- ip.txt
```
192.168.1.12
192.168.1.24
192.168.1.33
192.168.1.34
192.168.1.55
192.168.1.34
```

可以利用這樣的指令做掃描，來取得主機存活資訊
```
sudo nmap -sn -oA tnet -iL hosts.lst
```
## 同時掃描多個ip位置
```
nmap -sn -oA tnet 10.129.2.18 10.129.2.19 10.129.2.20| grep for | cut -d" " -f5
```

## 服務掃描
>[!NOTE]
>在系統攻擊前，需要先知道目標在執行那些服務，只知道ip是不夠的，所以我們需要利用一些工具來進行目標的列舉。
- Nmap主要可以刺探下列資訊
	- Open ports and its services
	- Service versions
	- Information that the services provided
	- Operating system

Nmap對於目標的掃描結果有幾個state:

| **State**          | **Description**                                                                                                                                                                                         |
| ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `open`             | This indicates that the connection to the scanned port has been established. These connections can be **TCP connections**, **UDP datagrams** as well as **SCTP associations**.                          |
| `closed`           | When the port is shown as closed, the TCP protocol indicates that the packet we received back contains an `RST` flag. This scanning method can also be used to determine if our target is alive or not. |
| `filtered`         | Nmap cannot correctly identify whether the scanned port is open or closed because either no response is returned from the target for the port or we get an error code from the target.                  |
| `unfiltered`       | This state of a port only occurs during the **TCP-ACK** scan and means that the port is accessible, but it cannot be determined whether it is open or closed.                                           |
| `open\|filtered`   | If we do not get a response for a specific port, `Nmap` will set it to that state. This indicates that a firewall or packet filter may protect the port.                                                |
| `closed\|filtered` | This state only occurs in the **IP ID idle** scans and indicates that it was impossible to determine if the scanned port is closed or filtered by a firewall.                                           |
### 掃描TCP服務
>[!NOTE]
>利用Nmap掃描TCP port是最常見的用法，利用Nmap可以很快的發現主機使用的服務以及有開啟的port，以利後續的滲透。

Nmap預設會做1000個最常見的TCP port，並且使用SYN Scan
```
nmap 10.129.66.45
```


可以利用參數做調整，使用`--top-ports`可以調整常用的port
``` 
 nmap 10.129.66.45 --top-ports=10 
```



可以顯示Nmap顯示送出跟送回的封包
```
nmap 10.129.2.28 -p22,80,110 --packet-trace --disable-arp-ping -Pn -n --reason -sT
```


Nmap的TCP常見使用指令:
- 常用的掃描指令
```
nmap -sS -p- -T4 192.168.100.1
```
- Nmap掃描 Full-scan
```
nmap -p- 192.168.50.149
```
- 針對port位掃描
```
nmap -sC -sV -p80,135,445 192.168.100.1
```
- SYN-Scan
```
nmap -sS 192.168.50.149
```
- TCP-Scan
```
nmap -sT 192.168.50.149
```
### 掃描UDP服務
>[!NOTE]
>相比TCP，UDP能做探刺到的資料就比較少，畢竟UDP是stateless protocol，而且UDP掃描的時間也會比較長。

使用Nmap做 UDP掃描
```
sudo nmap 10.129.2.28 -F -sU
```
- -F : 掃描常見的100個port
- -sU : UDP Scan


### 掃描服務版本
>[!NOTE]
>可用於探刺服務的版本，比如說探刺80port的apache版本。

```
sudo nmap 10.129.2.49 -sV -p80
```
 
## 使用Nmap腳本
>[!NOTE]
>Nmap Scripting Engine (NSE) 是Nmap的一個亮眼的功能，NSE是用Lua轉寫的掃描腳本，可以用於各種不同的情境。

Nmap大約內建14種不同的NSE掃描腳本

| **Category** | **Description**                                                                                                                         |
| ------------ | --------------------------------------------------------------------------------------------------------------------------------------- |
| `auth`       | Determination of authentication credentials.                                                                                            |
| `broadcast`  | Scripts, which are used for host discovery by broadcasting and the discovered hosts, can be automatically added to the remaining scans. |
| `brute`      | Executes scripts that try to log in to the respective service by brute-forcing with credentials.                                        |
| `default`    | Default scripts executed by using the `-sC` option.                                                                                     |
| `discovery`  | Evaluation of accessible services.                                                                                                      |
| `dos`        | These scripts are used to check services for denial of service vulnerabilities and are used less as it harms the services.              |
| `exploit`    | This category of scripts tries to exploit known vulnerabilities for the scanned port.                                                   |
| `external`   | Scripts that use external services for further processing.                                                                              |
| `fuzzer`     | This uses scripts to identify vulnerabilities and unexpected packet handling by sending different fields, which can take much time.     |
| `intrusive`  | Intrusive scripts that could negatively affect the target system.                                                                       |
| `malware`    | Checks if some malware infects the target system.                                                                                       |
| `safe`       | Defensive scripts that do not perform intrusive and destructive access.                                                                 |
| `version`    | Extension for service detection.                                                                                                        |
| `vuln`       | Identification of specific vulnerabilities.                                                                                             |
使用Nmap NSE的方式如下
- 預設模式
```
nmap <target> -sC
```
- 指定腳本模式
```
nmap <target> --script <category>
```
- 多腳本模式
```
nmap <target> --script <script-name>,<script-name>,...
```
- 大絕招模式(使用 -sC -sV -O --traceroute)
```
nmap <target> -p 80 -A
```

## 繞過防火牆
> [!WARNING]
> 我認位這邊大部分招數對現代防火牆都沒有用

### Decoys
>[!NOTE]
>設定Decoys可以讓Nmap隨機換來原IP位置，被block的機會就變得比較少

```
nmap 10.129.2.28 -p 80 -sS -Pn -n --disable-arp-ping --packet-trace -D RND:5
```

也可以單純換成其他的IP位置，有時侯選擇跟目標同網段的ip可能會有比較好的結果，這邊需要配合tunnel的IP位置。

```shell
nmap 10.129.2.28 -n -Pn -p 445 -O -S 10.129.2.200 -e tun0
```
### DNS Proxying
>[!NOTE]
>當我們在DMZ的時候，可以嘗試用DNS Proxying，被內網認可的可能性比較高，DNS Proxying其實就是把Source Port改成53。

```
nmap 10.129.2.28 -p50000 -sS -Pn -n --disable-arp-ping --packet-trace --source-port 53
```

>如果都不行，就用netcat去戳顯示filter的port看看吧

```
ncat -nv --source-port 53 10.129.2.28 50000
```


# rustscan

>[!NOTE]
>OSCP friendly 工具，可以快速做 port scan
- rustscan基礎掃描 
```
rustscan -a 192.168.100.1 -u 5000 -t 80000 --scripts none
```
-  rustscan整合nmap
```
rustscan -a 192.168.100.1 -u 5000 -t 80000 --scripts -- -n -Pn -sC -sV -oN mylist.txt
```
# nmapAutomator
>[!NOTE]
>作者表示是為了OSCP考試設計的工具，供參考

[nmapAutomator](https://github.com/rkhal101/nmapAutomator/tree/master)
## 基礎指令運用
1. **Quick:** Shows all open ports quickly (~15 seconds)
2. **Basic:** Runs Quick Scan, then runs a more thorough scan on found ports (~5 minutes)
3. **UDP:** Runs "Basic" on UDP ports (~5 minutes)
4. **Full:** Runs a full range port scan, then runs a thorough scan on new ports (~5-10 minutes)
5. **Vulns:** Runs CVE scan and nmap Vulns scan on all found ports (~5-15 minutes)
6. **Recon:** Runs "Basic" scan "if not yet run", then suggests recon commands "i.e. gobuster, nikto, smbmap" based on the found ports, then prompts to automatically run them
7. **All:** Runs all the scans consecutively (~20-30 minutes)

``` shell
./nmapAutomator.sh <TARGET-IP> <TYPE>  
./nmapAutomator.sh 10.1.1.1 All  
./nmapAutomator.sh 10.1.1.1 Basic  
./nmapAutomator.sh 10.1.1.1 Recon  
```
## 捷徑執行建立
``` shell
ln -s /PATH-TO-FOLDER/nmapAutomator.sh /usr/local/bin/
```
# 針對內網掃描的手法
- Bash Ping Sweep
```shell-session
for i in {1..254} ;do (ping -c 1 172.16.5.$i | grep "bytes from" &) ;done
```
- Cmd Ping Sweep
```cmd-session
for /L %i in (1 1 254) do ping 172.16.5.%i -n 1 -w 100 | find "Reply"
```
```
for /L %i in (1,1,255) do @ping -n 1 -w 200 172.16.6.%i > nul && echo 172.16.6.%i is up.
```
- Powershell Ping Sweep
```powershell-session
1..254 | % {"172.16.5.$($_): $(Test-Connection -count 1 -comp 172.15.5.$($_) -quiet)"}
```
- Meterpreter 
```shell-session
run post/multi/gather/ping_sweep RHOSTS=172.16.5.0/23
```